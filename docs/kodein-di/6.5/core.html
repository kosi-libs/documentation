<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Core documentation :: Kodein-Framework Documentation</title>
    <link rel="canonical" href="https://kodein.org/documentation/kodein-di/6.5/core.html">
    <meta name="generator" content="Antora 2.3.3">
    <link rel="stylesheet" href="../../_/css/site.css">
  </head>
  <body class="article">
<header class="header">
      <nav class="navbar">
        <div class="navbar-brand">
          <a class="navbar-item" href="https://kodein.org/documentation">
            <div class="navbar-brand-logo"></div>
            <div style="font-weight: 700;">KODEIN</div>
            <div style="font-weight: 300; opacity:0.8;">Framework</div>
          </a>
        </div>
        <div id="topbar-nav" class="navbar-menu">
          <div class="navbar-end">
            <a class="navbar-item" href="https://kodein.net" target="_blank">
              <div style="font-weight: 300;opacity:0.8;padding-right: 0.5rem">by</div>
              <div style="font-weight: 700;">KODEIN</div>
              <div style="font-weight: 300;opacity:0.8;">Koders</div>
            </a>
          </div>
        </div>
    </nav>
</header>
<div class="body">
<div class="nav-container" data-component="kodein-di" data-version="6.5">
  <div class="navbar-bottom-line-linear"></div>
  <aside class="nav">
    <div class="panels">
<div class="nav-panel-menu is-active" data-panel="menu">
  <nav class="nav-menu">
    <h3 class="title"><a href="index.html">Kodein-DI</a></h3>
<ul class="nav-list">
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="index.html">Home</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="getting-started.html">Getting started</a>
  </li>
  <li class="nav-item is-current-page" data-depth="1">
    <a class="nav-link" href="core.html">Core documentation</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="0">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Frameworks support</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="framework/android.html">Android</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="framework/ktor.html">Ktor</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="framework/tornadofx.html">TornadoFX</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="0">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Extensions</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="extension/configurable.html">Configurable &amp; global container</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="extension/jsr330.html">JSR-330 compatibility</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="0">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Migration guides</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="migration/migration-4to5.html">Kodein version 4 to version 5</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="migration/migration-j2k.html">JSR-330 to Kodein-DI</a>
  </li>
</ul>
  </li>
</ul>
  </nav>
</div>
<div class="nav-panel-explore" data-panel="explore">
  <div class="context">
    <span class="title">Kodein-DI</span>
    <span class="version">6.5</span>
  </div>
  <ul class="components">
    <li class="component">
      <span class="title">Kodein-DB</span>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../kodein-db/0.2.0/index.html">0.2.0</a>
        </li>
      </ul>
    </li>
    <li class="component is-current">
      <span class="title">Kodein-DI</span>
      <ul class="versions">
        <li class="version">
          <a href="../7.1/index.html">7.1 dev</a>
        </li>
        <li class="version is-latest">
          <a href="../7.0/index.html">7.0</a>
        </li>
        <li class="version is-current">
          <a href="index.html">6.5</a>
        </li>
      </ul>
    </li>
    <li class="component">
      <span class="title">Kodein-Framework</span>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../kodein-framework/index.html">master</a>
        </li>
      </ul>
    </li>
    <li class="component">
      <span class="title">Kodein-Log</span>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../kodein-log/0.5.0/index.html">0.5.0</a>
        </li>
      </ul>
    </li>
  </ul>
</div>
    </div>
  </aside>
</div>
<main class="article">
  <div class="navbar-bottom-line-gradient"></div>
  <div class="toolbar" role="navigation">
<button class="nav-toggle"></button>
  <a href="../../kodein-framework/index.html" class="home-link"></a>
<nav class="breadcrumbs" aria-label="breadcrumbs">
  <ul>
    <li><a href="index.html">Kodein-DI</a></li>
    <li><a href="core.html">Core documentation</a></li>
  </ul>
</nav>
<div class="page-versions">
  <button class="version-menu-toggle" title="Show other versions of page">6.5</button>
  <div class="version-menu">
    <a class="version is-missing" href="../7.1/index.html">7.1 dev</a>
    <a class="version is-missing" href="../7.0/index.html">7.0</a>
    <a class="version is-current" href="core.html">6.5</a>
  </div>
</div>
  <div class="edit-this-page"><a href="https://github.com/Kodein-Framework/Kodein-DI/edit/6.5/doc/modules/ROOT/pages/core.adoc">Edit this Page</a></div>
  </div>
  <div class="content">
<article class="doc">
<h1 class="page">Core documentation</h1>
<div class="sect1">
<h2 id="_introduction"><a class="anchor" href="#_introduction"></a>Introduction</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_description"><a class="anchor" href="#_description"></a>Description</h3>
<div class="paragraph lead">
<p>Kodein is a very useful dependency injection / retrieval container, it is very easy to use and configure.</p>
</div>
<div class="ulist">
<div class="title">Kodein allows you to:</div>
<ul>
<li>
<p>Lazily instantiate your dependencies when needed.</p>
</li>
<li>
<p>Stop caring about dependency initialization order.</p>
</li>
<li>
<p>Easily bind classes or interfaces to their instance, provider or factory.</p>
</li>
<li>
<p>Easily debug your dependency bindings and recursions.</p>
</li>
</ul>
</div>
<div class="ulist">
<div class="title">Kodein is a good choice because:</div>
<ul>
<li>
<p>It is small, fast and optimized (makes extensive use of <code>inline</code>).</p>
</li>
<li>
<p>It proposes a very simple and readable declarative DSL.</p>
</li>
<li>
<p>It is not subject to type erasure (like Java).</p>
</li>
<li>
<p>It integrates nicely with Android.</p>
</li>
<li>
<p>It proposes a very kotlin-esque idiomatic API.</p>
</li>
<li>
<p>It can be used in plain Java.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_example"><a class="anchor" href="#_example"></a>Example</h3>
<div class="paragraph">
<p>Kodein makes it very easy to bind a type:</p>
</div>
<div class="listingblock">
<div class="title">Example bindings:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">val kodein = Kodein {
    bind&lt;Dice&gt;() with provider { RandomDice(0, 5) }
    bind&lt;DataSource&gt;() with singleton { SqliteDS.open("path/to/file") }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Once bindings are declared, Kodein allows you to either inject or retrieve the dependencies for a class.</p>
</div>
<div class="paragraph">
<p>If you want your class to be unaware of dependency retrieval, then you can <strong>inject</strong> dependencies at construction:</p>
</div>
<div class="listingblock">
<div class="title">Using Kodein&#8217;s dependency injection via construction:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">class Controller(private val ds: DataSource) {
    /*...*/
}
val controller by kodein.newInstance { Controller(instance()) }</code></pre>
</div>
</div>
<div class="paragraph">
<p>If you want your class to handle it&#8217;s dependencies by itself, then you can have it easily <strong>retrieve</strong> them:</p>
</div>
<div class="listingblock">
<div class="title">Using Kodein&#8217;s dependency injection via construction:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">class Controller(override val kodein: Kodein): KodeinAware {
    private val ds: DataSource by instance()
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_platform_compatibility_genericity"><a class="anchor" href="#_platform_compatibility_genericity"></a>Platform compatibility &amp; Genericity</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Kodein is compatible with all platforms that the Kotlin language compiles to: JVM &amp; compatible (Android), Javascript and all the Kotlin/Native targets.</p>
</div>
<div class="paragraph">
<p>On the JVM &amp; compatible (Android), you need to choose to use either the <code>erased</code> or the <code>generic</code> version.<br>
On the Javascript and Native targets, only the <code>erased</code> version is available.</p>
</div>
<div class="paragraph">
<p>The difference is very simple: the <code>generic</code> version is <strong>NOT</strong> subject to type erasure while the <code>erased</code> version <strong>IS</strong>.</p>
</div>
<div class="paragraph">
<p>Of course, it is a little bit more complicated!<br>
To be able to circumvent the type erasure that&#8217;s inherent to the JVM bytecode, the <code>generic</code> version uses a trix that makes heavy use of reflexivity.
Because the <code>erased</code> version does not use that trix, handling generic types in Kodein are a lot more complex to use.</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 20%;">
<col style="width: 20%;">
<col style="width: 20%;">
<col style="width: 20%;">
<col style="width: 20%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">&nbsp;</th>
<th class="tableblock halign-left valign-top">Type erasure</th>
<th class="tableblock halign-left valign-top">Optimized</th>
<th class="tableblock halign-left valign-top">Non-generic bindings</th>
<th class="tableblock halign-left valign-top">Generic bindings</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>generic</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>immune</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">no</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>simple</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>simple</strong></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>erased</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">subject</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>yes</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>simple</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">complex</p></td>
</tr>
</tbody>
</table>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Yes, #perfmatters. However, the humble opinion of the author is that:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>There is a balance to be found between performance, readability, security and debuggability.</p>
</li>
<li>
<p>Optimisation is important <strong>in critical path</strong>, not <em>everywhere</em>.</p>
</li>
<li>
<p>Kodein is already pretty optimized ;)</p>
</li>
<li>
<p>In the vast majority of cases, using the erased version will result in <strong>no significant performance change</strong> to your application, as IoC happens once and is not a performance pitfall!</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Therefore, please make sure that, using the erased version is right for your use case, before blindly using it ;).
<strong>Do profile your code</strong>!</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>On the JVM, you might prefer the erased version if:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>You are confident you are not binding / injecting / retrieving generic types and you are sure <strong>none of the libraries you are using are</strong>.</p>
</li>
<li>
<p>You are not using <a href="#set-bindings">set bindings</a>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>If you profile your code and find that injection is a performance pitfall, then it probably is instanciation: you are creating too many objects in critical paths.
Reusing objects in critical paths will enhance performance both in dependency injection / retrieval and in GC!</p>
</div>
<div class="paragraph">
<p>If you are using the erased version, either by choice on the JVM, or by default on JS &amp; Native, you should read <a href="#erased-version">erased version pitfalls</a>.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="install"><a class="anchor" href="#install"></a>Install</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_jvm"><a class="anchor" href="#_jvm"></a>JVM</h3>
<div class="sect3">
<h4 id="_with_maven"><a class="anchor" href="#_with_maven"></a>With Maven</h4>
<div class="paragraph">
<p>Add the JCenter repository:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;repositories&gt;
    &lt;repository&gt;
      &lt;id&gt;jcenter&lt;/id&gt;
      &lt;url&gt;https://jcenter.bintray.com&lt;/url&gt;
    &lt;/repository&gt;
&lt;/repositories&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Then add the dependency:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;dependencies&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.kodein.di&lt;/groupId&gt;
        &lt;artifactId&gt;kodein-di-generic-jvm&lt;/artifactId&gt;
        &lt;version&gt;6.5.5&lt;/version&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Use <code>kodein-di-generic-jvm</code> or <code>kodein-di-erased-jvm</code>.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_with_gradle"><a class="anchor" href="#_with_gradle"></a>With Gradle</h4>
<div class="paragraph">
<p>Add the JCenter repository:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">buildscript {
    repositories {
        jcenter()
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Then add the dependency:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">dependencies {
    implementation 'org.kodein.di:kodein-di-generic-jvm:6.5.5'
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Use <code>kodein-di-generic-jvm</code> or <code>kodein-di-erased-jvm</code>.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_javascript_gradle"><a class="anchor" href="#_javascript_gradle"></a>JavaScript (Gradle)</h3>
<div class="paragraph">
<p>Because Kodein for JavaScript is compiled as a <a href="https://github.com/umdjs/umd">UMD module</a>, it can be imported:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>In a browser:</p>
<div class="ulist">
<ul>
<li>
<p>as an AMD module (for example with RequireJS) (See index.html in the demo project).</p>
</li>
<li>
<p>Directly in an HTML page with a <code>&lt;script&gt;</code> tag (See index2.html in the demo project).</p>
</li>
</ul>
</div>
</li>
<li>
<p>In NodeJS, as a regular CJS module.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Add the JCenter repository:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">buildscript {
    repositories {
        jcenter()
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Then add the dependency:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">dependencies {
    compile 'org.kodein.di:kodein-di-erased-js:6.5.5'
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_native_gradle"><a class="anchor" href="#_native_gradle"></a>Native (Gradle)</h3>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Kodein supports the following targets:<br>
      androidArm32, androidArm64, iosArm32, iosArm64, iosX64, linuxArm32Hfp, linuxMips32, linuxMipsel32, linuxX64, macosX64, mingwX64
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Kodein-DI uses the new gradle native dependency model.
Because that model is experimental in gradle, it is not forward compatible with next versions of Gradle.</p>
</div>
<div class="paragraph">
<p>Add the JCenter repository:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">buildscript {
    repositories {
        jcenter()
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Then add the dependency:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">kotlin {
    sourceSets {
        commonMain {
            dependencies {
                implementation "org.kodein.di:kodein-di-erased:6.5.5"
            }
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="declaring-dependencies"><a class="anchor" href="#declaring-dependencies"></a>Bindings: Declaring dependencies</h2>
<div class="sectionbody">
<div class="listingblock">
<div class="title">Example: initialization of a Kodein container</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">val kodein = Kodein {
	/* Bindings */
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Bindings are declared inside a Kodein initialization block.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
If you are using <code>kodein-di-generic-jvm</code>, Kodein <strong>not</strong> subject to type erasure (e.g. You can bind both a <code>List&lt;Int&gt;</code> and a <code>List&lt;String&gt;</code>).
</td>
</tr>
</table>
</div>
<div class="admonitionblock caution">
<table>
<tr>
<td class="icon">
<i class="fa icon-caution" title="Caution"></i>
</td>
<td class="content">
This is <strong>NOT</strong> the case when using <code>kodein-di-erased-jvm</code>, <code>kodein-erased-js</code> or <code>kodein-erased-native</code>.
         With the <code>erased</code> version by default, binding <code>List&lt;Int&gt;</code> and <code>List&lt;String&gt;</code> actually means binding <code>List&lt;*&gt;</code> twice.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>A binding always starts with <code>bind&lt;TYPE&gt;() with</code>.</p>
</div>
<div class="paragraph lead">
<p>There are different ways to declare bindings:</p>
</div>
<div class="sect2">
<h3 id="tagged-bindings"><a class="anchor" href="#tagged-bindings"></a>Tagged bindings</h3>
<div class="paragraph">
<p>All bindings can be tagged to allow you to bind different instances of the same type.</p>
</div>
<div class="listingblock">
<div class="title">Example: different Dice bindings</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">val kodein = Kodein {
    bind&lt;Dice&gt;() with ... <i class="conum" data-value="1"></i><b>(1)</b>
    bind&lt;Dice&gt;(tag = "DnD10") with ... <i class="conum" data-value="2"></i><b>(2)</b>
    bind&lt;Dice&gt;(tag = "DnD20") with ... <i class="conum" data-value="2"></i><b>(2)</b>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Default binding (with no tag)</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Bindings with tags (<code>"DnD10"</code> and <code>"DnD20"</code>)</td>
</tr>
</table>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
The tag is of type <code>Any</code>, it does not have to be a <code>String</code>.
</td>
</tr>
</table>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
Whether at define, at injection or at retrieval, <code>tag</code> should always be passed as a named argument.
</td>
</tr>
</table>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
Tag objects must support equality &amp; hashcode comparison.
           It is therefore recommended to either use primitives (Strings, Ints, etc.) or data classes.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_provider_binding"><a class="anchor" href="#_provider_binding"></a>Provider binding</h3>
<div class="paragraph">
<p>This binds a type to a provider function, which is a function that takes no arguments and returns an object of the bound type (eg. <code>() &#8594; T</code>).<br>
The provided function will be called <strong>each time</strong> you need an instance of the bound type.</p>
</div>
<div class="listingblock">
<div class="title">Example: creates a new 6 sided Dice entry each time you need one</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">val kodein = Kodein {
    bind&lt;Dice&gt;() with provider { RandomDice(6) }
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_singleton_binding"><a class="anchor" href="#_singleton_binding"></a>Singleton binding</h3>
<div class="paragraph">
<p>This binds a type to an instance of this type that will lazily be created at first use via a singleton function, which is a function that takes no arguments and returns an object of the bound type (eg. <code>() &#8594; T</code>).<br>
Therefore, the provided function will be called <strong>only once</strong>: the first time an instance is needed.</p>
</div>
<div class="listingblock">
<div class="title">Example: creates a DataSource singleton that will be initialized on first access</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">val kodein = Kodein {
    bind&lt;DataSource&gt;() with singleton { SqliteDS.open("path/to/file") }
}</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="_non_synced_singleton"><a class="anchor" href="#_non_synced_singleton"></a>Non-synced singleton</h4>
<div class="paragraph">
<p>By definition, there can be only one instance of a singleton, which means only one instance can be constructed.
To achieve this certainty, Kodein synchronizes construction.
This means that, when a singleton instance is requested and not available, Kodein uses a synchronization mutex to ensure that other request to the same type will wait for this instance to be constructed.</p>
</div>
<div class="paragraph">
<p>While this behaviour is the only way to ensure the singleton&#8217;s correctness, it is also costly (due to the mutex) and degrades startup performance.</p>
</div>
<div class="paragraph">
<p>If you need to improve startup performance, <em>if you know what you are doing</em>, you can disable this synchronization.</p>
</div>
<div class="listingblock">
<div class="title">Example: creates a DataSource non synced singleton</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">val kodein = Kodein {
    bind&lt;DataSource&gt;() with singleton(sync = false) { SqliteDS.open("path/to/file") }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Using <code>sync = false</code> means that:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>There will be no construction synchronicity.</p>
</li>
<li>
<p>There <em>may</em> be multiple instance constructed.</p>
</li>
<li>
<p>Instance will be <em>reused</em> as much as possible.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_eager_singleton"><a class="anchor" href="#_eager_singleton"></a>Eager singleton</h4>
<div class="paragraph">
<p>This is the same as a regular singleton, except that the provided function will be called as soon as the Kodein instance is created and all bindings are defined.</p>
</div>
<div class="listingblock">
<div class="title">Example: creates a DataSource singleton that will be initialized as soon as the binding block ends</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">val kodein = Kodein {
    // The SQLite connection will be opened as soon as the kodein instance is ready
    bind&lt;DataSource&gt;() with eagerSingleton { SqliteDS.open("path/to/file") }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_factory_binding"><a class="anchor" href="#_factory_binding"></a>Factory binding</h3>
<div class="paragraph">
<p>This binds a type to a factory function, which is a function that takes an argument of a defined type and that returns an object of the bound type (eg. <code>(A) &#8594; T</code>).<br>
The provided function will be called <strong>each time</strong> you need an instance of the bound type.</p>
</div>
<div class="listingblock">
<div class="title">Example: creates a new Dice each time you need one, according to an Int representing the number of sides</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">val kodein = Kodein {
    bind&lt;Dice&gt;() with factory { sides: Int -&gt; RandomDice(sides) }
}</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="multi-argument-factories"><a class="anchor" href="#multi-argument-factories"></a>Multi-arguments factories</h4>
<div class="admonitionblock caution">
<table>
<tr>
<td class="icon">
<i class="fa icon-caution" title="Caution"></i>
</td>
<td class="content">
This multi-agrument-factories mechanism is deprecated and will be removed in version <code>7.0</code>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>A factory can take multiple (up to 5) arguments:</p>
</div>
<div class="listingblock">
<div class="title">Example: creates a new Dice each time you need one, according to an Int representing the number of sides</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">val kodein = Kodein {
    bind&lt;Dice&gt;() with factory { startNumber: Int, sides: Int -&gt; RandomDice(sides) }
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
We recommand to use <code>data classes</code> instead!
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Regarding our users feedbacks, we find out that multi-arguments factories was difficult to use.</p>
</div>
<div class="paragraph">
<p>Thus this mechanism will be deprecate soon. So we highly recommend that you migrate your multi-args factories to simple factories by using <strong>data classes</strong>.</p>
</div>
<div class="listingblock">
<div class="title">Example: creates a new Dice each time you need one, according to multiple parameters</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">data class DiceParams(val startNumber: Int, val sides: Int)

val kodein = Kodein {
    bind&lt;Dice&gt;() with factory { params: DiceParams -&gt; RandomDice(params) }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_multiton_binding"><a class="anchor" href="#_multiton_binding"></a>Multiton binding</h3>
<div class="paragraph">
<p>A multiton can be thought of a "singleton factory": it guarantees to always return the same object given the same argument.
In other words, for a given argument, the first time a multiton is called with this argument, it will call the function to create an instance; and will always yield that same instance when called with the same argument.</p>
</div>
<div class="listingblock">
<div class="title">Example: creates one random generator for each value</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">val kodein = Kodein {
    bind&lt;RandomGenerator&gt;() with multiton { max: Int -&gt; SecureRandomGenerator(max) }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Just like a factory, a multiton can take multiple (up to 5) arguments.</p>
</div>
<div class="sect3">
<h4 id="_non_synced_multiton"><a class="anchor" href="#_non_synced_multiton"></a>non-synced multiton</h4>
<div class="paragraph">
<p>Just like a singleton, a multiton synchronization can be disabled:</p>
</div>
<div class="listingblock">
<div class="title">Example: non-synced multiton</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">val kodein = Kodein {
    bind&lt;RandomGenerator&gt;(sync = false) with multiton { max: Int -&gt; SecureRandomGenerator(max) }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_referenced_singleton_or_multiton_binding"><a class="anchor" href="#_referenced_singleton_or_multiton_binding"></a>Referenced singleton or multiton binding</h3>
<div class="paragraph">
<p>A referenced singleton is an object that is guaranteed to be single as long as a reference object can return it.
A referenced multiton is an object that is guaranteed to be single for the same argument as long as a reference object can return it.</p>
</div>
<div class="paragraph">
<p>A referenced singleton or multiton needs a "reference maker" in addition to the classic construction function that determines the type of reference that will be used.</p>
</div>
<div class="paragraph lead">
<p>Kodein comes with three reference makers for the JVM:</p>
</div>
<div class="sect3">
<h4 id="_jvm_soft_weak"><a class="anchor" href="#_jvm_soft_weak"></a>JVM: Soft &amp; weak</h4>
<div class="paragraph">
<p>These are objects that are guaranteed to be single in the JVM at a given time, but not guaranteed to be single during the application lifetime.
If there are no more strong references to the instances, they may be GC&#8217;d and later, re-created.</p>
</div>
<div class="paragraph">
<p>Therefore, the provided function <strong>may or may not</strong> be called multiple times during the application lifetime.</p>
</div>
<div class="listingblock">
<div class="title">Example: creates a Cache object that will exist only once at a given time</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">val kodein = Kodein {
    bind&lt;Map&gt;() with singleton(ref = softReference) { WorldMap() } <i class="conum" data-value="1"></i><b>(1)</b>
    bind&lt;Client&gt;() with singleton(ref = weakReference) { id -&gt; clientFromDB(id) } <i class="conum" data-value="2"></i><b>(2)</b>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Because it&#8217;s bound by a soft reference, the JVM will GC it before any <code>OutOfMemoryException</code> can occur.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Because it&#8217;s bound by a weak reference, the JVM will GC it is no more referenced.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Weak singletons use JVM&#8217;s <code>WeakReference</code> while soft singletons use JVM&#8217;s <code>SoftReference</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="_jvm_thread_local"><a class="anchor" href="#_jvm_thread_local"></a>JVM: Thread local</h4>
<div class="paragraph">
<p>This is the same as the standard singleton binding, except that each thread gets a different instance.
Therefore, the provided function will be called <strong>once per thread</strong> that needs the instance, the first time it is requested.</p>
</div>
<div class="listingblock">
<div class="title">Example: creates a Cache object that will exist once per thread</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">val kodein = Kodein {
    bind&lt;Cache&gt;() with singleton(ref = threadLocal) { LRUCache(16 * 1024) }
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Semantically, thread local singletons should use <a href="#scoped-singletons">[scoped-singletons]</a>, the reason it uses a referenced singleton is because Java&#8217;s <code>ThreadLocal</code> acts like a reference.
</td>
</tr>
</table>
</div>
<div class="admonitionblock caution">
<table>
<tr>
<td class="icon">
<i class="fa icon-caution" title="Caution"></i>
</td>
<td class="content">
Thread locals are not available in JavaScript.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_instance_binding"><a class="anchor" href="#_instance_binding"></a>Instance binding</h3>
<div class="paragraph">
<p>This binds a type to an instance that <strong>already exist</strong>.</p>
</div>
<div class="listingblock">
<div class="title">Example: a DataSource binding to an already existing instance.</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">val kodein = Kodein {
    bind&lt;DataSource&gt;() with instance(SqliteDataSource.open("path/to/file")) <i class="conum" data-value="1"></i><b>(1)</b>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Instance is used <strong>with parenthesis</strong>: it is not given a function, but an instance.</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="constant-binding"><a class="anchor" href="#constant-binding"></a>Constant binding</h4>
<div class="paragraph">
<p>It is often useful to bind "configuration" constants.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Constants are always <a href="#tagged-bindings">tagged</a>.
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="title">Example: two constants</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">val kodein = Kodein {
    constant(tag = "maxThread") with 8 <i class="conum" data-value="1"></i><b>(1)</b>
    constant(tag = "serverURL") with "https://my.server.url" <i class="conum" data-value="1"></i><b>(1)</b>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Note the absence of curly braces: it is not given a function, but an instance.</td>
</tr>
</table>
</div>
<div class="admonitionblock caution">
<table>
<tr>
<td class="icon">
<i class="fa icon-caution" title="Caution"></i>
</td>
<td class="content">
You should only use constant bindings for very simple types without inheritance or interface (e.g. primitive types and data classes).
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_direct_binding"><a class="anchor" href="#_direct_binding"></a>Direct binding</h3>
<div class="paragraph">
<p>Sometimes, it may seem overkill to specify the type to <code>bind</code> if you are binding the same type as you are creating.</p>
</div>
<div class="paragraph">
<p>For this use case, you can transform any <code>bind&lt;Type&gt;() with &#8230;&#8203;</code> to <code>bind() from &#8230;&#8203;</code>.</p>
</div>
<div class="listingblock">
<div class="title">Example: direct bindings</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">val kodein = Kodein {
    bind() from singleton { RandomDice(6) }
    bind("DnD20") from provider { RandomDice(20) }
    bind() from instance(SqliteDataSource.open("path/to/file"))
}</code></pre>
</div>
</div>
<div class="admonitionblock caution">
<table>
<tr>
<td class="icon">
<i class="fa icon-caution" title="Caution"></i>
</td>
<td class="content">
<strong>This should be used with care</strong> as binding a concrete class and, therefore, having concrete dependencies is an <em>anti-pattern</em> that later prevents modularisation and mocking / testing.
</td>
</tr>
</table>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
When using <code>kodein-generic-*</code> and binding a generic type, the bound type will be the specialized type,<br>
         e.g. <code>bind() from singleton { listOf(1, 2, 3, 4) }</code> registers the binding to <code>List&lt;Int&gt;</code>.
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
If you are using Kodein/Native, because of <a href="https://github.com/JetBrains/kotlin-native/issues/1290">this bug</a>, you need to use the uppercase version: <code>Bind() from</code>.
      This issue has been fixed and the <code>bind() from</code> syntax will be available to Kodein/Native as soon as Kotlin/Native 0.6 is released.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_subtypes_bindings"><a class="anchor" href="#_subtypes_bindings"></a>Subtypes bindings</h3>
<div class="paragraph">
<p>Kodein allows you register a "subtype bindings factory".
These are big words for a simple concept that&#8217;s best explained with an example:</p>
</div>
<div class="listingblock">
<div class="title">Example: direct bindings</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">val kodein = Kodein {
    bind&lt;Controller&gt;().subtypes() with { type -&gt;
        when (type.jvmType) { <i class="conum" data-value="1"></i><b>(1)</b>
            MySpecialController::class.java -&gt; singleton { MySpecialController() }
            else -&gt; provider { myControllerSystem.getController(type.jvmType) }
        }
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>As <code>type</code> is a <code>TypeToken&lt;*&gt;</code>, you can use <code>.jvmType</code> to get the JVM type (e.g. <code>Class</code> or <code>ParameterizedType</code>).</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>In essence, <code>bind&lt;Whatever&gt;().subtypes() with { type &#8594; binding }</code> allows you to register, in Kodein, a binding factory that will be called for subtypes of the provided type.</p>
</div>
</div>
<div class="sect2">
<h3 id="_transitive_dependencies"><a class="anchor" href="#_transitive_dependencies"></a>Transitive dependencies</h3>
<div class="paragraph">
<p>With those lazily instantiated dependencies, a dependency (very) often needs another dependency.
Such classes can have their dependencies passed to their constructor.
Thanks to Kotlin&#8217;s <em>killer</em> type inference engine, Kodein makes retrieval of transitive dependencies really easy.</p>
</div>
<div class="listingblock">
<div class="title">Example: a class that needs transitive dependencies</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">class Dice(private val random: Random, private val sides: Int) {
/*...*/
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>It is really easy to bind this <code>RandomDice</code> with its transitive dependencies, by simply using <code>instance()</code> or <code>instance(tag)</code>.</p>
</div>
<div class="listingblock">
<div class="title">Example: bindings of a Dice and of its transitive dependencies</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">val kodein = Kodein {
    bind&lt;Dice&gt;() with singleton { Dice(instance(), instance(tag = "max")) } <i class="conum" data-value="1"></i><b>(1)</b>

    bind&lt;Random&gt;() with provider { SecureRandom() } <i class="conum" data-value="2"></i><b>(2)</b>
    constant(tag "max") with 5 <i class="conum" data-value="2"></i><b>(2)</b>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Binding of <code>Dice</code>. It gets its transitive dependencies by using <code>instance()</code> and <code>instance(tag)</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Bindings of <code>Dice</code> transitive dependencies.</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The order in which the bindings are declared has <strong>no importance whatsoever</strong>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The binding functions are in the same environment as the <code>newInstance</code> function described in the <a href="#injection">dependency injection section</a>.
You can read it to learn more about the <code>instance</code>, <code>provider</code> and <code>factory</code> functions available to the function.</p>
</div>
<div class="sect3">
<h4 id="_transitive_factory_dependencies"><a class="anchor" href="#_transitive_factory_dependencies"></a>Transitive factory dependencies</h4>
<div class="paragraph">
<p>Maybe you need a dependency to use one of its functions to create the bound type.</p>
</div>
<div class="listingblock">
<div class="title">Example: using a DataSource to create a Connection.</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">val kodein = Kodein {
    bind&lt;DataSource&gt;() with singleton { MySQLDataSource() }
    bind&lt;Connection&gt;() with provider { instance&lt;DataSource&gt;().openConnection() } <i class="conum" data-value="1"></i><b>(1)</b>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Using a <code>DataSource</code> as a transitive factory dependency.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_being_responsible_for_its_own_retrieval"><a class="anchor" href="#_being_responsible_for_its_own_retrieval"></a>Being responsible for its own retrieval</h3>
<div class="paragraph">
<p>If the bound class is <a href="#kodein-aware">KodeinAware</a>, you can pass the <code>kodein</code> object to the class so it can itself use the Kodein container to retrieve its own dependencies.</p>
</div>
<div class="listingblock">
<div class="title">Example: bindings of Manager that is responsible for retrieving its own dependencies</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">val kodein = Kodein {
    bind&lt;Manager&gt;() with singleton { ManagerImpl(kodein) } <i class="conum" data-value="1"></i><b>(1)</b>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>ManagerImpl is given a Kodein instance.</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_bindings_separation"><a class="anchor" href="#_bindings_separation"></a>Bindings separation</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_modules"><a class="anchor" href="#_modules"></a>Modules</h3>
<div class="sect3">
<h4 id="_definition"><a class="anchor" href="#_definition"></a>Definition</h4>
<div class="paragraph">
<p>Kodein allows you to export your bindings in modules.
It is very useful to have separate modules defining their own bindings instead of having only one central binding definition.
A module is an object that you can construct the exact same way as you construct a Kodein instance.</p>
</div>
<div class="listingblock">
<div class="title">Example: a simple module</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">val apiModule = Kodein.Module(name = "API") {
    bind&lt;API&gt;() with singleton { APIImpl() }
    /* other bindings */
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Then, in your Kodein binding block:</p>
</div>
<div class="listingblock">
<div class="title">Example: imports the module</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">val kodein = Kodein {
    import(apiModule)
    /* other bindings */
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Modules are <strong>definitions</strong>, they will re-declare their bindings in each Kodein instance you use.
      If you create a module that defines a singleton and import that module into two different Kodein instances, then the singleton object will exist twice: once in each Kodein instance.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="module-uniqueness"><a class="anchor" href="#module-uniqueness"></a>Name uniqueness</h4>
<div class="paragraph">
<p>Each module name should only be imported once.</p>
</div>
<div class="paragraph">
<p>If a second module with the name of an already imported module is imported, then Kodein will fail.</p>
</div>
<div class="paragraph">
<p>However, you cannot always ensure that every module name is unique: you may need to import modules that are defined outside of your code.
Kodein offers two ways to mitigate that:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Rename a module:<br>
Use when you are importing a module whose name already exists.</p>
<div class="listingblock">
<div class="title">Example: imports a renamed module</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">val kodein = Kodein {
    import(apiModule.copy(name = "otherAPI"))
}</code></pre>
</div>
</div>
</li>
<li>
<p>Add a prefix to modules imported by a module:<br>
Use when a module imported by another module uses a names which already exists.</p>
<div class="listingblock">
<div class="title">Example: imports a module with a prefix for sub-modules</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">val kodein = Kodein {
    import(apiModule.copy(prefix = "otherAPI-"))
}</code></pre>
</div>
</div>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="_import_once"><a class="anchor" href="#_import_once"></a>Import once</h4>
<div class="paragraph">
<p>You may define a module which you know depends on another module, so it would be great to import that dependency inside the module that has the dependency.
However, each module can only be imported once, so if every module that depends on another module imports it, Kodein will fail at the second module that imports it.</p>
</div>
<div class="paragraph">
<p>To support this, Kodein offers <code>importOnce</code>: it imports the module if no module with that name was previously imported.</p>
</div>
<div class="listingblock">
<div class="title">Example: importing a module only once</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">val appModule = Kodein.Module {
    importOnce(apiModule)
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_extension_composition"><a class="anchor" href="#_extension_composition"></a>Extension (composition)</h3>
<div class="paragraph">
<p>Kodein allows you to create a new Kodein instance by extending an existing one.</p>
</div>
<div class="listingblock">
<div class="title">Example: extends an already existing Kodein instance</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">val subKodein = Kodein {
    extend(appKodein)
    /* other bindings */
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
This <strong>preserves bindings</strong>, meaning that a singleton in the parent Kodein will continue to exist only once.
      Both parent and child Kodein objects will give the same instance.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_overriding"><a class="anchor" href="#_overriding"></a>Overriding</h3>
<div class="paragraph">
<p>By default, overriding a binding is not allowed in Kodein.
That is because accidentally binding twice the same (class,tag) to different instances/providers/factories can cause real headaches to debug.</p>
</div>
<div class="paragraph">
<p>However, when intended, it can be really interesting to override a binding, especially when creating a testing environment.
You can override an existing binding by specifying explicitly that it is an override.</p>
</div>
<div class="listingblock">
<div class="title">Example: binds twice the same type, the second time explitly specifying an override</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">val kodein = Kodein {
    bind&lt;API&gt;() with singleton { APIImpl() }
    /* ... */
    bind&lt;API&gt;(overrides = true) with singleton { OtherAPIImpl() }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>By default, <strong>modules are not allowed to override, <em>even explicitly</em></strong>.
You can allow a module to override some of your bindings when you import it (the same goes for extension):</p>
</div>
<div class="listingblock">
<div class="title">Example: imports a module and giving it the right to override existing bindings.</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">val kodein = Kodein {
    /* ... */
    import(testEnvModule, allowOverride = true)
}</code></pre>
</div>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
The bindings in the module still need to specify explicitly the overrides.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Sometimes, you just want to define bindings without knowing if you are actually overriding a previous binding or defining a new.
Those cases should be rare and you should know what you are doing.</p>
</div>
<div class="listingblock">
<div class="title">Example: declaring a module in which each binding may or may not override existing bindings.</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">val testModule = Kodein.Module(name = "test", allowSilentOverride = true) {
    bind&lt;EmailClient&gt;() with singleton { MockEmailClient() } <i class="conum" data-value="1"></i><b>(1)</b>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Maybe adding a new binding, maybe overriding an existing one, who knows?</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>If you want to access an instance retrieved by the overridden binding, you can use overriddenInstance.
This is useful if you want to "enhance" a binding (for example, using the decorator pattern).</p>
</div>
<div class="listingblock">
<div class="title">Example: declaring a module in which each binding may or may not override existing bindings.</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">val testModule = Kodein.Module(name = "test") {
    bind&lt;Logger&gt;(overrides = true) with singleton { FileLoggerWrapper("path/to/file", overriddenInstance()) } <i class="conum" data-value="1"></i><b>(1)</b>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td><code>overriddenInstance()</code> will return the <code>Logger</code> instance retrieved by the overridden binding.</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="overridden_access_from_parent"><a class="anchor" href="#overridden_access_from_parent"></a>Overridden access from parent</h3>
<div class="paragraph">
<p>Let&#8217;s consider the following code :</p>
</div>
<div class="listingblock">
<div class="title">Example: Mixing overriding &amp; extension</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">val parent = Kodein {
    bind&lt;Foo&gt;() with provider { Foo1() }
    bind&lt;Bar&gt;() with singleton { Bar(foo = instance&lt;Foo&gt;()) }
}

val child = Kodein {
    extend(parent)
    bind&lt;Foo&gt;(overrides = true) with provider { Foo2() }
}

val foo = child.instance&lt;Bar&gt;().foo</code></pre>
</div>
</div>
<div class="paragraph">
<p>In this example, the <code>foo</code> variable will be of type <code>Foo1</code>.
Because the <code>Bar</code> binding is a <code>singleton</code> and is declared in the <code>parent</code> Kodein, it <strong>does not have access to bindings declared in <code>child</code>.</strong>
In this example, both <code>parent.instance&lt;Bar&gt;().foo</code> and <code>child.instance&lt;Bar&gt;().foo</code> will yield a <code>Foo1</code> object.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
This is because <code>Bar</code> is bound to a <code>singleton</code>, the first access would define the container used (<code>parent</code> or <code>child</code>).
If the singleton were initialized by <code>child</code>, then a subsequent access from <code>parent</code> would yeild a <code>Bar</code> with a reference to a <code>Foo2</code>, which is not supposed to exist in <code>parent</code>.
</td>
</tr>
</table>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
By default, <strong>all bindings that do not cache instances</strong> (basically all bindings but <code>singleton</code> and <code>multiton</code>) <strong>are copied by default into the new container</strong>, and therefore have access to the bindings &amp; overrides of this new container.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>If you want the <code>Bar</code> singleton to have access to the overridden <code>Foo</code> binding, you need to copy it into the <code>child</code> container.</p>
</div>
<div class="listingblock">
<div class="title">Example: Copying the bar binding into the child container</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">val child = Kodein {
    extend(parent, copy = Copy {
        copy the binding&lt;Bar&gt;() <i class="conum" data-value="1"></i><b>(1)</b>
    })
    bind&lt;Foo&gt;(overrides = true) with provider { Foo2() }
}</code></pre>
</div>
</div>
<div class="admonitionblock caution">
<table>
<tr>
<td class="icon">
<i class="fa icon-caution" title="Caution"></i>
</td>
<td class="content">
Copying a binding means that it will exists once more.
Therefore, a copied singleton will <strong>no longer be unique</strong> and have TWO instances, one managed by each binding (the original and the copied).
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>If the binding you need to copy is bound by a context (such as a scoped singleton), you need to specify it:</p>
</div>
<div class="listingblock">
<div class="title">Example: Copying a tagged scoped singleton</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">val parent = Kodein {
    bind&lt;Session&gt;(tag = "req") with scoped(requestScope).singleton { context.session() }
}

val child = Kodein {
    extend(parent, copy = Copy {
        copy the binding&lt;Session&gt;() with scope(requestScope) and tag("req")
    })
    bind&lt;Foo&gt;(overrides = true) with provider { Foo2() }
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
You can use the <code>context&lt;&gt;()</code>, <code>scope()</code> and <code>tag()</code> functions to specialise your binding copies.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>You can also copy all bindings that matches a particular definition :</p>
</div>
<div class="listingblock">
<div class="title">Example: Copying all that matches</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">val child = Kodein {
    extend(parent, copy = Copy {
        copy all binding&lt;String&gt;() <i class="conum" data-value="1"></i><b>(1)</b>
        copy all scope(requestScope) <i class="conum" data-value="2"></i><b>(2)</b>
    })
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Will copy all bindings for a <code>String</code>, with or without a context, scope, tag or argument.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Will copy all bindings that are scoped inside a <code>RequestScope</code>.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Finally, you can simply copy <strong>all</strong> bindings:</p>
</div>
<div class="listingblock">
<div class="title">Example: Copying all</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">val child = Kodein {
    extend(parent, copy = Copy.All)
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Or you can decide that none are copied (if you do want existing bindings to have access to new bindings):</p>
</div>
<div class="listingblock">
<div class="title">Example: Copying none</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">val child = Kodein {
    extend(parent, copy = Copy.None)
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_dependency_injection_retrieval"><a class="anchor" href="#_dependency_injection_retrieval"></a>Dependency injection &amp; retrieval</h2>
<div class="sectionbody">
<div class="listingblock">
<div class="title">Example bindings that are used throughout the chapter:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">val kodein = Kodein {
    bind&lt;Dice&gt;() with factory { sides: Int -&gt; RandomDice(sides) }
    bind&lt;DataSource&gt;() with singleton { SqliteDS.open("path/to/file") }
    bind&lt;Random&gt;() with provider { SecureRandom() }
    bind&lt;FileAccess&gt;() with factory { path: String, mode: Int -&gt; FileAccess.open(path, mode) }
    constant("answer") with "fourty-two"
}</code></pre>
</div>
</div>
<div class="sect2">
<h3 id="_retrieval_rules"><a class="anchor" href="#_retrieval_rules"></a>Retrieval rules</h3>
<div class="ulist">
<div class="title">When retrieving a dependency, the following rules apply:</div>
<ul>
<li>
<p>A dependency bound with a <code>provider</code>, an <code>instance</code>, a <code>singleton</code>, an <code>eagerSingleton</code>, or a <code>constant</code> can be retrieved:</p>
<div class="ulist">
<ul>
<li>
<p>as a provider method: <code>() &#8594; T</code></p>
</li>
<li>
<p>as an instance: <code>T</code></p>
</li>
</ul>
</div>
</li>
<li>
<p>A dependency bound with a <code>factory</code> or a <code>multiton</code> can only be retrieved as a factory method: <code>(A) &#8594; T</code>.</p>
<div class="ulist">
<ul>
<li>
<p>as a factory method: <code>(A) &#8594; T</code></p>
</li>
<li>
<p>as a provider method: <code>() &#8594; T</code> <em>if the argument <code>A</code> is provided at retrieval</em>.</p>
</li>
<li>
<p>as an instance: <code>T</code> <em>if the argument <code>A</code> is provided at retrieval</em>.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_injection_retrieval"><a class="anchor" href="#_injection_retrieval"></a>Injection &amp; Retrieval</h3>
<div class="paragraph">
<p>When dependencies are <strong>injected</strong>, the class is <em>provided</em> its dependencies at construction.<br>
When dependencies are <strong>retrieved</strong>, the class is <em>responsible</em> for getting its own dependencies.</p>
</div>
<div class="paragraph">
<p>Using dependency <strong>injection</strong> is a bit more cumbersome, but your classes are "pure": they are unaware of the dependency container.
Using dependency <strong>retrieval</strong> is easier (and allows more tooling), but it does binds your classes to the Kodein API.</p>
</div>
<div class="paragraph">
<p>Finally, in retrieval, <strong>everything is lazy by default</strong>, while there can be no lazy-loading using injection.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
If you are developing a library, then you probably should use dependency <strong>injection</strong>, to avoid forcing the users of your library to use Kodein as well.<br>
     If you are developing an application, then you should consider using dependency <strong>retrieval</strong>, as it is easier to use and provides more tooling.
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="_base_methods"><a class="anchor" href="#_base_methods"></a>Base methods</h4>
<div class="paragraph">
<p>Whether you are using dependency injection or retrieval, the same 3 methods will be available with the same name and parameters (but not return type).<br>
These methods are:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>instance()</code> if you need an instance: <code>T</code>.</p>
</li>
<li>
<p><code>provider()</code> if you need a provider: <code>() &#8594; T</code>.</p>
</li>
<li>
<p><code>factory()</code> if you need an instance: <code>(A) &#8594; T</code>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>All three methods can take a <code>tag</code> argument.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>The <code>tag</code> argument should always be named.</p>
</div>
<div class="listingblock">
<div class="title">Example: Using the named tag argument.</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">instance(tag = "whatever").</code></pre>
</div>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="injection"><a class="anchor" href="#injection"></a>Injection</h3>
<div class="paragraph">
<p>To use dependency injection,</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Declare your dependencies in the constructor of your classes.</p>
</li>
<li>
<p>Use Kodein&#8217;s <code>newInstance</code> method to create an object of such class.</p>
</li>
</ol>
</div>
<div class="sect3">
<h4 id="_simple_case"><a class="anchor" href="#_simple_case"></a>Simple case</h4>
<div class="listingblock">
<div class="title">Example: a MainController class with a 2 dependencies constructor.</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">class MainController(val ds: DataSource, val rnd: Random) { /*...*/ }</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Example: Creating a MainController by injecting its dependencies.</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">val controller by kodein.newInstance { MainController(instance(), instance(tag = "whatever")) } <i class="conum" data-value="1"></i><b>(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Note the use of the <code>instance</code> function that will inject the correct dependency.</td>
</tr>
</table>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
When injecting a type that was not bound, a <code>Kodein.NotFoundException</code> will be thrown.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>If you are not sure (or simply do not know) if the type has been bound, you can use <code>*OrNull</code> methods.</p>
</div>
</div>
<div class="sect3">
<h4 id="_multi_arguments_factories"><a class="anchor" href="#_multi_arguments_factories"></a>Multi-arguments factories</h4>
<div class="paragraph">
<p>When injecting a value that was bound with a <a href="#multi-argument-factories">multi-argument factory</a>,
the arguments must be wrapped inside a <strong>data class</strong>:</p>
</div>
<div class="listingblock">
<div class="title">Example: Creating a FileController by injecting a multi-argument bound dependency.</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">data class ControllerParams(val path: String, val timeout: Int)
val controller by kodein.newInstance { FileController(instance(args = ControllerParams("path/to/file", 0))) }</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_currying_factories"><a class="anchor" href="#_currying_factories"></a>Currying factories</h4>
<div class="paragraph">
<p>You can retrieve a provider or an instance from a factory bound type by using the <code>arg</code> parameter (this is called <em>currying</em>).</p>
</div>
<div class="listingblock">
<div class="title">Example: a RollController class with a constructor dependency bound to a factory.</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">class RollController(val dice: Dice) { /*...*/ }</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Example: Creating a RollController by injecting its dependency.</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">val controller by kodein.newInstance { RollController(instance(arg = 6)) }</code></pre>
</div>
</div>
<div class="paragraph">
<p>Note that if you want to bind a factory with multiple argument, you need to use a <strong>data class</strong> to pass multiple arguments:</p>
</div>
<div class="listingblock">
<div class="title">Example: Creating a multi-argument RollController by injecting its dependency.</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">data class Params(val arg1: Int, val arg2: Int)
val controller by kodein.newInstance { RollController(instance(arg = Params(60, 6))) }</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
The <code>arg</code> argument should always be named.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_defining_context"><a class="anchor" href="#_defining_context"></a>Defining context</h4>
<div class="paragraph">
<p>When retrieving, you sometimes need to manually define a context (for example, when retrieving a scoped singleton).
For this, you can use the <code>on</code> method:</p>
</div>
<div class="listingblock">
<div class="title">Example: Setting a global context.</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">val controller by kodein.on(context = myContext).newInstance { OtherController(instance(arg = 6), instance()) }</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
The <code>context</code> argument should always be named.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Sometimes, the context is not available directly at construction.
When that happens, you can define a lazy context that will be accessed only when needed.</p>
</div>
<div class="listingblock">
<div class="title">Example: Setting a global context.</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">val controller by kodein.on { requireActivity() } .newInstance { OtherController(instance(arg = 6), instance()) }</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_retrieval_the_kodein_container"><a class="anchor" href="#_retrieval_the_kodein_container"></a>Retrieval: the Kodein container</h3>
<div class="sect3">
<h4 id="_everything_is_lazy_by_default"><a class="anchor" href="#_everything_is_lazy_by_default"></a>everything is lazy by default!</h4>
<div class="paragraph">
<p>In the next few sections, we will be describing dependency retrieval.
As you might have guessed by the title of this section, everything, in dependency retrieval, is lazy by default.</p>
</div>
<div class="paragraph">
<p>This allows:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Dependencies to be retrieved only when they are actually needed.</p>
</li>
<li>
<p>"Out of context" classes such as Android Activities to access their dependencies once their contexts have been initialized.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>If you want "direct" retrieval, well, there&#8217;s a section named <a href="#direct-retrieval">direct retrieval</a>, how about that!</p>
</div>
</div>
<div class="sect3">
<h4 id="_kodein_methods"><a class="anchor" href="#_kodein_methods"></a>Kodein methods</h4>
<div class="paragraph">
<p>You can retrieve a bound type via a Kodein instance.</p>
</div>
<div class="listingblock">
<div class="title">Example: retrieving bindings</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">val diceFactory: (Int) -&gt; Dice by kodein.factory()
val dataSource: DataSource by kodein.instance()
val randomProvider: () -&gt; Random by kodein.provider()
val answerConstant: String by kodein.instance(tag = "answer")</code></pre>
</div>
</div>
<div class="paragraph">
<p>Note the use of the <code>by</code>.
Kodein uses <a href="https://kotlinlang.org/docs/reference/delegated-properties.html::">delegated properties</a> to enable:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Lazy loading</p>
</li>
<li>
<p>Accessing the receiver</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
When using a provider function (<code>() &#8594; T</code>), whether this function will give each time a new instance or the same depends on the binding.
</td>
</tr>
</table>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
When asking for a type that was not bound, a <code>Kodein.NotFoundException</code> will be thrown.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>If you are not sure (or simply do not know) if the type has been bound, you can use <code>*OrNull</code> methods.</p>
</div>
<div class="listingblock">
<div class="title">Example: retrieving bindings that may not have been bound</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">val diceFactory: ((Int) -&gt; Dice)? by kodein.factoryOrNull()
val dataSource: DataSource? by kodein.instanceOrNull()
val randomProvider: (() -&gt; Random)? by kodein.providerOrNull()
val answerConstant: String? by kodein.instanceOrNull(tag = "answer")</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_constants"><a class="anchor" href="#_constants"></a>Constants</h4>
<div class="paragraph">
<p>If you bound <a href="#constant-binding">constants</a>, you can easily retrieve them with the constant method if the name of the property matches the tag:</p>
</div>
<div class="listingblock">
<div class="title">Example: retrieving a constant</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">val answer: String by kodein.constant()</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_named_bindings"><a class="anchor" href="#_named_bindings"></a>Named bindings</h4>
<div class="paragraph">
<p>If you used <a href="#tagged-bindings">tagged bindings</a>, if the tag is a <code>String</code> and the property name matches the tag, instead of passing it as argument, you can use <code>named</code>:</p>
</div>
<div class="listingblock">
<div class="title">Example: retrieving a named binding</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">val answer: String by kodein.named.instance()</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_multi_arguments_factories_2"><a class="anchor" href="#_multi_arguments_factories_2"></a>Multi-arguments factories</h4>
<div class="paragraph">
<p>When retrieving a value that was bound with a <a href="#multi-argument-factories">multi-argument factory</a>, the arguments must be wrapped inside a <strong>data class</strong>:</p>
</div>
<div class="listingblock">
<div class="title">Example: Creating a MainController by injecting a multi-argument bound dependency.</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">data class FileParams(val path: String, val maxSize: Int)
val fileAccess: FileAccess by kodein.instance(args = FileParams("/path/to/file", 0))</code></pre>
</div>
</div>
<div class="sect4">
<h5 id="_factory_retrieval"><a class="anchor" href="#_factory_retrieval"></a>Factory retrieval</h5>
<div class="paragraph">
<p>Instead of retrieving a value, you can retrieve a factory, that can call as much as you need.</p>
</div>
<div class="listingblock">
<div class="title">Example: Retrieving factory.</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">val f1: (Int) -&gt; Int by kodein.factory() <i class="conum" data-value="1"></i><b>(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>retrieving a factory that takes 1 argument (Int) and return an Int</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_currying_factories_2"><a class="anchor" href="#_currying_factories_2"></a>Currying factories</h4>
<div class="paragraph">
<p>You can retrieve a provider or an instance from a factory bound type by using the <code>arg</code> parameter (this is called <em>currying</em>).</p>
</div>
<div class="listingblock">
<div class="title">Example: currying factories</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">val sixSideDiceProvider: () -&gt; Dice by kodein.provider(arg = 6)
val twentySideDice: Dice by kodein.instance(arg = 20)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Note that if you bound a factory with multiple arguments, you need to use a <strong>data class</strong> to pass multiple arguments:</p>
</div>
<div class="listingblock">
<div class="title">Example: Creating a multi-argument Dice by injecting its dependency.</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">data class DiceParams(val startNumber: Int, val sides: Int)
val sixtyToSixtySixDice: Dice by kodein.instance(arg = DiceParams(60, 6)) <i class="conum" data-value="1"></i><b>(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Bonus points if you can say the variable name 5 times in less than 5 seconds ;)</td>
</tr>
</table>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
The <code>arg</code> argument should always be named.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_defining_context_2"><a class="anchor" href="#_defining_context_2"></a>Defining context</h4>
<div class="paragraph">
<p>Whether you are using a scoped singleton/multiton or using a context in the target binding, you may need to specify a context.</p>
</div>
<div class="listingblock">
<div class="title">Example: Getting a Session after setting the Request context.</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">val session: Session by kodein.on(context = request).instance()</code></pre>
</div>
</div>
<div class="paragraph">
<p>If you retrieve multiple dependencies all using the same context, you can create a new <code>Kodein</code> object with the context set:</p>
</div>
<div class="listingblock">
<div class="title">Example: creating a Kodein object with the Request context.</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">val reqKodein = kodein.on(context = request)
val session: Session by reqKodein.instance()</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
The <code>context</code> argument should always be named.
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Using a global context does not forces you to use only bindings that are declared with this type of context.
      Because the default context is <code>Any?</code>, all non-contexted bindings will still be available with a global context set.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_using_a_trigger"><a class="anchor" href="#_using_a_trigger"></a>Using a Trigger</h4>
<div class="paragraph">
<p>There is a mechanism that allows you to decide when dependencies are actually retrieved if you want them to be retrieved at a particular time and not at first access.
This mechanism is called a Trigger.</p>
</div>
<div class="listingblock">
<div class="title">Example: using a trigger.</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">val trigger = KodeinTrigger()
val dice: Dice by kodein.on(trigger = trigger).instance()
/*...*/
trigger.trigger() <i class="conum" data-value="1"></i><b>(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Retrieval happens now.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>You can, of course, assign multiple properties to the same trigger.
You can also create a Kodein object that has a given trigger by default:</p>
</div>
<div class="listingblock">
<div class="title">Example: creating a Kodein object with a trigger.</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">val trigger = KodeinTrigger()
val injectKodein = kodein.on(trigger = trigger)
val dice: Dice by injectKodein.instance()
/*...*/
trigger.trigger()</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
The <code>trigger</code> argument should always be named.
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
A trigger allows you to "force" retrieval.
      However, retrieval can still happen before <code>inject()</code> is called if the variable is accessed.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_lazy_access"><a class="anchor" href="#_lazy_access"></a>Lazy access</h4>
<div class="paragraph">
<p>Kodein proposes a <code>LazyKodein</code> object that allows you to lazily access the Kodein object only when needed.
This is useful if:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>You need to defined a lazily retrieved dependency before having access to a Kodein container.</p>
</li>
<li>
<p>You don&#8217;t know if you&#8217;ll ever need to access a Kodein object.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>For this, you can use a <code>LazyKodein</code>:</p>
</div>
<div class="listingblock">
<div class="title">Example: Using a LazyKodein.</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">val kodein = LazyKodein { /* access to a kodein instance */ }
val ds: DataSource by kodein.instance()
/*...*/
dice.roll() <i class="conum" data-value="1"></i><b>(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Only then will the Kodein instance will itself be retrieved.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Note that you can also lazily create a <code>Kodein</code> object so that the bindings definition function will only be called when the first retrieved property is needed:</p>
</div>
<div class="listingblock">
<div class="title">Example: Using a lazy Kodein.</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">val kodein by Kodein.lazy {
    bind&lt;Env&gt;() with instance(Env.getInstance())
}
val env: Env by kodein.instance()
/*...*/
env.doSomething() <i class="conum" data-value="1"></i><b>(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Only then will the Kodein instance will itself be created, and the bindings definition function ran.</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_late_init"><a class="anchor" href="#_late_init"></a>Late init</h4>
<div class="paragraph">
<p>Kodein proposes a <code>LateInitKodein</code> that allows you to define a Kodein object <em>after</em> some lazy retrieval:</p>
</div>
<div class="listingblock">
<div class="title">Example: Using a LateInitKodein.</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">val kodein = LateInitKodein()
val env: Env by kodein.instance()
/*...*/
kodein.baseKodein = /* access to a kodein instance */ <i class="conum" data-value="1"></i><b>(1)</b>
/*...*/
env.doSomething() <i class="conum" data-value="2"></i><b>(2)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Setting the real Kodein object.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>If this was run before setting <code>kodein.baseKodein</code>, an <code>UninitializedPropertyAccessException</code> would be thrown.</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_all_matches"><a class="anchor" href="#_all_matches"></a>All matches</h4>
<div class="paragraph">
<p>Kodein allows you to retrieve all instances that matches a given type:</p>
</div>
<div class="listingblock">
<div class="title">Example: all instances of Foo.</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">val instances: List&lt;Foo&gt; by kodein.allInstances() <i class="conum" data-value="1"></i><b>(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Will return all instances that are for bindings of sub-classes of <code>Foo</code></td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Of course, <code>allProviders</code> and <code>allFactories</code> are also provided ;)
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="kodein-aware"><a class="anchor" href="#kodein-aware"></a>Retrieval: being KodeinAware</h3>
<div class="sect3">
<h4 id="_simple_retrieval"><a class="anchor" href="#_simple_retrieval"></a>Simple retrieval</h4>
<div class="paragraph">
<p>You can have classes that implement the interface <code>KodeinAware</code>.<br>
Doing so has the benefit of getting a simpler syntax for retrieval.</p>
</div>
<div class="listingblock">
<div class="title">Example: a KodeinAware class</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">class MyManager(override val kodein: Kodein) : KodeinAware {
    private val diceFactory: ((Int) -&gt; Dice)? by factoryOrNull()
    private val dataSource: DataSource? by instanceOrNull()
    private val randomProvider: (() -&gt; Random)? by providerOrNull()
    private val answerConstant: String? by instanceOrNull(tag = "answer")
    private val sixSideDiceProvider: () -&gt; Dice by kodein.provider(arg = 6)
    private val twentySideDice: Dice by kodein.instance(arg = 20)
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>All methods that are available to the Kodein container are available to a <code>KodeinAware</code> class.</p>
</div>
</div>
<div class="sect3">
<h4 id="_class_global_context"><a class="anchor" href="#_class_global_context"></a>Class global context</h4>
<div class="paragraph">
<p>In a <code>KodeinAware</code> class, to define a context that&#8217;s valid for the entire class, you can simply override the <code>kodeinContext</code> property:</p>
</div>
<div class="listingblock">
<div class="title">Example: a KodeinAware class with a context</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">class MyManager(override val kodein: Kodein) : KodeinAware {
    override val kodeinContext = kcontext(whatever) <i class="conum" data-value="1"></i><b>(1)</b>
    /*...*/
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Note the use of the <code>kcontext</code> function that creates a <code>KodeinContext</code> with the given value.</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Using a global context does not forces you to use only bindings that are declared with this type of context.
      Because the default context is <code>Any?</code>, all non-contexted bindings will still be available with a global context set.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Sometimes, the context is not available directly at construction.
When that happens, you can define a lazy context that will be accessed only when needed.</p>
</div>
<div class="listingblock">
<div class="title">Example: a KodeinAware class with a context</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">class MyManager(override val kodein: Kodein) : KodeinAware {
    override val kodeinContext = kcontext { requireActivity }
    /*...*/
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_class_global_trigger"><a class="anchor" href="#_class_global_trigger"></a>Class global trigger</h4>
<div class="paragraph">
<p>If you want to have all dependency properties retrieved at once, you can use a class global trigger.
Simply override the <code>kodeinTrigger</code> property:</p>
</div>
<div class="listingblock">
<div class="title">Example: a KodeinAware class with a trigger</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">class MyManager(override val kodein: Kodein) : KodeinAware {
    override val kodeinTrigger = KodeinTrigger()
    val ds: DataSource by instance()
    /*...*/
    fun onReady() {
        kodeinTrigger.trigger() <i class="conum" data-value="1"></i><b>(1)</b>
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Retrieval of all dependencies happens now.</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_lazy_access_2"><a class="anchor" href="#_lazy_access_2"></a>Lazy access</h4>
<div class="paragraph">
<p>Some classes (such as Android Activities) do not have access to a <code>Kodein</code> instance at the time of construction, but only later when they have been properly connected to their environment (Android context).<br>
Because Kodein is lazy by default, this does not cause any issue: simply have the kodein property be lazy by itself:</p>
</div>
<div class="listingblock">
<div class="title">Example: an Activity class with a lazy-loaded kodein</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">class MyActivity : Activity(), KodeinAware {
    override val kodein by lazy { (applicationContext as MyApplication).kodein }
    val ds: DataSource by instance() <i class="conum" data-value="1"></i><b>(1)</b>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Because <code>ds</code> is lazily retrieved, access to the <code>kodein</code> property will only happen at first retrieval.</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
There is an official module to ease the use of Kodein in Android, you can read more about it on <a href="framework/android.html" class="page">the dedicated document</a>.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_lateinit"><a class="anchor" href="#_lateinit"></a>Lateinit</h4>
<div class="paragraph">
<p>Because everything is lazy and, in a KodeinAware class, the Kodein object is not accessed until needed, you can easily declare the <code>kodein</code> field as lateinit.</p>
</div>
<div class="listingblock">
<div class="title">Example: an Activity class with a lateinit kodein</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">class MyActivity : Activity(), KodeinAware {
    override val lateinit kodein: Kodein
    val ds: DataSource by instance() <i class="conum" data-value="1"></i><b>(1)</b>
    override fun onCreate(savedInstanceState: Bundle?) {
        kodein = (applicationContext as MyApplication).kodein
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Because <code>ds</code> is lazily retrieved, access to the <code>kodein</code> property will only happen at first retrieval.</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_all_matches_2"><a class="anchor" href="#_all_matches_2"></a>All matches</h4>
<div class="paragraph">
<p>Kodein allows you to retrieve all instances that matches a given type:</p>
</div>
<div class="listingblock">
<div class="title">Example: all instances of Foo.</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">val instances: List&lt;Foo&gt; = dkodein.allInstances() <i class="conum" data-value="1"></i><b>(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Will return all instances that are for bindings of sub-classes of <code>Foo</code></td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Of course, <code>allProviders</code> and <code>allFactories</code> are also provided ;)
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="direct-retrieval"><a class="anchor" href="#direct-retrieval"></a>Retrieval: Direct</h3>
<div class="paragraph">
<p>If you don&#8217;t want to use delegated properties, Kodein has you covered.
Most of the features available to <code>Kodein</code> are available to <code>DKodein</code> (D is for Direct).
<code>DKodein</code> allows you to directly get a new instance or dependency.</p>
</div>
<div class="paragraph">
<p>However, because it is direct, <code>DKodein</code> does <strong>NOT</strong> feature:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Laziness: the instance/provider/factory is fetched at call time.</p>
</li>
<li>
<p>Receiver awareness: receiver is defined by the Kotlin&#8217;s delegated properties mechanism.</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="title">Example: using a DKodein</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">val dk = kodein.direct

val ds: Datasource = dk.instance()

val controller = dk.newInstance { MainController(instance(), instance(tag = "whatever")) }</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>If you only plan to use direct access, you can define your main kodein object to be a <code>DKodein</code>:</p>
</div>
<div class="listingblock">
<div class="title">Example: using a DKodein</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">val kodein = Kodein.direct { <i class="conum" data-value="1"></i><b>(1)</b>
        /* bindings */
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>&lt;1&gt;: Note the <code>.direct</code>.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="_being_dkodeinaware"><a class="anchor" href="#_being_dkodeinaware"></a>Being DKodeinAware</h4>
<div class="paragraph">
<p>Much like <code>Kodein</code> offers <code>KodeinAware</code>, <code>DKodein</code> offers <code>DKodeinAware</code></p>
</div>
<div class="listingblock">
<div class="title">Example: a DKodeinAware class</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">class MyManager(override val dkodein: DKodein) : DKodeinAware {
    private val diceFactory: ((Int) -&gt; Dice)? = factoryOrNull()
    private val dataSource: DataSource? = instanceOrNull()
    private val randomProvider: (() -&gt; Random)? = providerOrNull()
    private val answerConstant: String? = instanceOrNull(tag = "answer")
    private val sixSideDiceProvider: () -&gt; Dice = kodein.provider(arg = 6)
    private val twentySideDice: Dice = kodein.instance(arg = 20)
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_in_java"><a class="anchor" href="#_in_java"></a>In Java</h4>
<div class="paragraph">
<p>While Kodein does not allow you to declare modules or dependencies in Java, it does allow you to retrieve dependencies via <code>DKodein</code>.
Simply give the DKodein instance to your Java classes, use Kodein in Java with the <code>TT</code> static function:</p>
</div>
<div class="listingblock">
<div class="title">Example: using Kodein in Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">import static org.kodein.di.TypesKt.TT;

public class JavaClass {
    private final Function1&lt;Integer, Dice&gt; diceFactory;
    private final Datasource dataSource;
    private final Function0&lt;Random&gt; randomProvider;
    private final String answerConstant;

    public JavaClass(DKodein kodein) {
        diceFactory = kodein.Factory(TT(Integer.class), TT(Dice.class), null);
        dataSource = kodein.Instance(TT(Datasource.class), null);
        randomProvider = kodein.Provider(TT(Random.class), null);
        answerConstant = kodein.Instance(TT(String.class), "answer");
    }}</code></pre>
</div>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Remember that Java is subject to type erasure.
Therefore, if you registered a generic Class binding such as <code>bind&lt;List&lt;String&gt;&gt;()</code>, in order to retrieve it you have to use <code>TypeReference</code> to circumvent Java&#8217;s type erasure.</p>
</div>
<div class="listingblock">
<div class="title">Example: using TypeReference in Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">class JavaClass {
    private final List&lt;String&gt; list;

    public JavaClass(TKodein kodein) {
        list = kodein.Instance(TT(new TypeReference&lt;List&lt;String&gt;&gt;() {}), null);
    }
}</code></pre>
</div>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_error_messages"><a class="anchor" href="#_error_messages"></a>Error messages</h3>
<div class="paragraph">
<p>By default, Kodein error messages contains the classes simple names (e.g. <code>View</code>), which makes it easily readable.<br>
If you want the error to contain classes full names (e.g. <code>com.company.app.UserController.View</code>), you can set <code>fullDescriptionOnError</code>:</p>
</div>
<div class="listingblock">
<div class="title">Example: showing qualified names in errors</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">val kodein = Kodein {
    fullDescriptionOnError = true
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>If you are using multiple Kodein instances, you can set the default value <code>fullDescriptionOnError</code> for all subsequently created Kodein instances:</p>
</div>
<div class="listingblock">
<div class="title">Example: showing qualified names in all kodein instances errors</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">Kodein.defaultFullDescriptionOnError = true</code></pre>
</div>
</div>
<div class="admonitionblock caution">
<table>
<tr>
<td class="icon">
<i class="fa icon-caution" title="Caution"></i>
</td>
<td class="content">
<code>Kodein.defaultFullDescriptionOnError</code> must be set <strong>before</strong> creating a Kodein instance.
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_using_the_environment"><a class="anchor" href="#_using_the_environment"></a>Using the environment</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Binding functions have access to the environment where the bound type is retrieved to be able to create it accordingly.</p>
</div>
<div class="sect2">
<h3 id="_context"><a class="anchor" href="#_context"></a>Context</h3>
<div class="paragraph lead">
<p>This environment is represented as a <strong>context</strong> variable.</p>
</div>
<div class="paragraph">
<p>The context is an object that is explicitly defined by the programmer for this retrieval or the receiving object when none is explicitely defined.</p>
</div>
<div class="paragraph">
<p>There are two very important differences between a tag and a context:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The tag <strong>instance</strong> identifies the binding but can not be used in the binding function.</p>
</li>
<li>
<p>The context <strong>type</strong> identifies the binding and it&#8217;s <strong>instance</strong> can be used in the binding function.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>There are also two very important differences between a factory argument and a context:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The context is defined <em>before</em> retrieving the binding function while the factory argument is the last known variable.</p>
</li>
<li>
<p>A context is usually global to an entire class while a factory argument is local to a retrieval.</p>
</li>
</ul>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
When in doubt, use a factory with an argument instead of a provider with a context.
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="title">Example: binding in a context</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">val kodein = Kodein {
    bind&lt;Writer&gt;() with contexted&lt;Request&gt;.provider { context.response.writer } <i class="conum" data-value="1"></i><b>(1)</b>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>note that <code>context</code> is already of type <code>Request</code>.</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_scope"><a class="anchor" href="#_scope"></a>Scope</h3>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Kodein provides only 1 scope by default, but:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>It is easy to create your own scopes.</p>
</li>
<li>
<p>All <code>kodein-framework-*</code> modules provide more scopes that are specific to the target framework.</p>
</li>
</ul>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Scopes are derived from a context variable.
They allow a singleton or multiton objects to exist multiple times in different contexts.<br>
They are of type <code>Scope&lt;C&gt;</code> where <code>C</code> is the context type.</p>
</div>
<div class="paragraph">
<p>Think, for example, of a session object inside a web server.
We can say that there can be only one user per session, and therefore define a <code>User</code> singleton scoped in a session.
Therefore, the provided function will be called <strong>once per session</strong>.</p>
</div>
<div class="listingblock">
<div class="title">Example: binding a User in a Session scope.</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">val kodein = Kodein {
    bind&lt;User&gt;() with scoped(SessionScope).singleton { UserData(session.userId) } <i class="conum" data-value="1"></i><b>(1)</b>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>note that <code>SessionScope</code> does not really exist, it is an example.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>In this example, <code>SessionScope</code> is of type <code>Scope&lt;Session&gt;</code>, so to access this binding, the user will either have retrieve it inside the session object or explicitly define a <code>Session</code> context:</p>
</div>
<div class="listingblock">
<div class="title">Example: binding in a context</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">val user by kodein.on(session).instance()</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Please read the <a href="#scope-creation">Scope creation</a> section if you want to create your own scopes.
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="scope-closeable"><a class="anchor" href="#scope-closeable"></a>Scope closeable</h4>
<div class="paragraph">
<p>By default, a Singleton or a Multiton value will never expire.
However, the purpose of a Scope is to handle the lifecycle of a long lived value.
Therefore, it is possible for a scoped Singleton or Multiton value to expire (most of the time because the scope itself expires).
For example, in android&#8217;s <code>ActivityRetainedScope</code>, scoped values will only live the duration of the activity.</p>
</div>
<div class="paragraph">
<p>If a value implements <code>ScopeCloseable</code>, it&#8217;s <code>close</code> function will be called when the value is removed from the scope (or when the scope itself expires).</p>
</div>
<div class="admonitionblock caution">
<table>
<tr>
<td class="icon">
<i class="fa icon-caution" title="Caution"></i>
</td>
<td class="content">
<div class="paragraph">
<p>The <code>ScopeCloseable.close</code> method will only be called:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>By scopes that explicitely <strong>support</strong> that feature (not all scopes do, all scopes provided by the Kodein Framework do <strong>except WeakContextScope</strong>).</p>
</li>
<li>
<p>If the value does <strong>not</strong> use <code>WeakRef</code> or <code>SoftRef</code> references.<br>
If the value does, the close method <em>may or may not</em> be called (it will be called if the reference has not expired).</p>
</li>
</ul>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_jvm_references_in_scopes"><a class="anchor" href="#_jvm_references_in_scopes"></a>JVM references in scopes</h4>
<div class="paragraph">
<p>Yes, you can&#8230;&#8203;</p>
</div>
<div class="listingblock">
<div class="title">Example: JVM scoped weak references.</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">val kodein = Kodein {
    bind&lt;User&gt;() with scoped(requestScope).singleton(ref = weakReference) {
        instance&lt;DataSource&gt;().createUser(context.session.id)
    } <i class="conum" data-value="1"></i><b>(1)</b>
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_weak_context_scope"><a class="anchor" href="#_weak_context_scope"></a>Weak Context Scope</h4>
<div class="paragraph">
<p>Kodein provides the <code>WeakContextScope</code> scope.
This is a particular scope, as the context it holds on are weak references.</p>
</div>
<div class="admonitionblock caution">
<table>
<tr>
<td class="icon">
<i class="fa icon-caution" title="Caution"></i>
</td>
<td class="content">
WeakContextScope is <strong>NOT</strong> compatible with <code>ScopeCloseable</code>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>You can use this scope when it makes sense to have a scope on a context that is held by the system for the duration of its life cycle.</p>
</div>
<div class="listingblock">
<div class="title">Example: controller scoped to an Activity with WeakContextScope.</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">val kodein = Kodein {
    bind&lt;Controller&gt;() with scoped(WeakContextScope.of&lt;Activity&gt;()).singleton { ControllerImpl(context) } <i class="conum" data-value="1"></i><b>(1)</b>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td><code>context</code> is of type <code>Activity</code> because we are using the <code>WeakContextScope.of&lt;Activity&gt;()</code>.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code>WeakContextScope.of</code> will always return the same scope, which you should never clean!</p>
</div>
<div class="paragraph">
<p>If you need a compartimentalized scope which you can clean, you can create a new <code>WeakContextScope</code>:</p>
</div>
<div class="listingblock">
<div class="title">Example: creating a WeakContextScope.</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">val activityScope = WeakContextScope&lt;Activity&gt;()</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="context_translators"><a class="anchor" href="#context_translators"></a>Context translators</h4>
<div class="paragraph">
<p>Let&#8217;s get back to the web server example.
There is one session per user, so we have bound a <code>User</code> singleton inside a <code>Session</code> scope.
As each <code>Request</code> is associated with a <code>Session</code>, you can register a context translator that will make any binding that needs a <code>Session</code> context work with a <code>Request</code> context:</p>
</div>
<div class="listingblock">
<div class="title">Example:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">val kodein = Kodein {
    bind&lt;User&gt;() with scoped(SessionScope).singleton { UserData(session.userId) }

    registerContextTranslator { r: Request -&gt; r.session }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>This allows you to retrieve a <code>User</code> instance:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>When there is a global <code>Request</code> context:</p>
<div class="listingblock">
<div class="title">Example: retriving with a global context</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">class MyController(override val kodein: Kodein, request: Request): KodeinAware {
    override val kodeinContext = kcontext(request)

    val user: User by instance()
}</code></pre>
</div>
</div>
</li>
<li>
<p>When the retrieval happens on a <code>Request</code> itself:</p>
<div class="listingblock">
<div class="title">Example: retriving with a global context</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">class MySpecialRequest(override val kodein: Kodein): Request(), KodeinAware {
    val user: User by instance()
}</code></pre>
</div>
</div>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_context_finder"><a class="anchor" href="#_context_finder"></a>Context finder</h4>
<div class="paragraph">
<p>A context finder is a similar to context translator, except that it gets the context from a global context.</p>
</div>
<div class="paragraph">
<p>For example, if you are in a thread-based server where each request is assigned a thread (are people still doing those?!?), you could get the session from a global:</p>
</div>
<div class="listingblock">
<div class="title">Example:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">val kodein = Kodein {
    bind&lt;User&gt;() with scoped(SessionScope).singleton { UserData(session.userId) }

    registerContextFinder { ThreadLocalSession.get() }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>This allows to access a <code>User</code> object wihout specifying a context.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
Having an other type of context declared will not block from using a context finder.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="scope-creation"><a class="anchor" href="#scope-creation"></a>Scope creation</h3>
<div class="paragraph">
<p>Scoped singletons/multitons are bound to a context and live while that context exists.</p>
</div>
<div class="paragraph">
<p>To define a scope that can contain scoped singletons or multitons, you must define an object that implements the <code>Scope</code> interface.
This object will be responsible for providing a <code>ScopeRegistry</code> according to a context.
It should always return the same <code>ScopeRegistry</code> when given the same context object.
A standard way of doing so is to use the <code>userData</code> property of the context, if it has one, or else to use a <code>WeakHashMap&lt;C, ScopeRegistry&gt;</code>.</p>
</div>
<div class="listingblock">
<div class="title">Example: a simple session scope</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">object SessionScope : Scope&lt;Session&gt; { <i class="conum" data-value="1"></i><b>(1)</b>
    override fun getRegistry(context: Session): ScopeRegistry =
            context.userData as? ScopeRegistry
                ?: StandardScopeRegistry().also { context.userData = it } <i class="conum" data-value="2"></i><b>(2)</b>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The scope&#8217;s context type is <code>Session</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Creates a <code>ScopeRegistry</code> and attach it to the <code>Session</code> if there is none.</td>
</tr>
</table>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
Scope providers should also provide standard context translators.<br>
           In this example, we should provide, along with <code>sessionScope</code> a module providing the <code>Request</code> to <code>Session</code> context translator.
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="scope-registry"><a class="anchor" href="#scope-registry"></a>Scope registry</h4>
<div class="paragraph">
<p>The <code>ScopeRegistry</code> is responsible for holding value instances.
It is also responsible for calling the <code>close</code> methods on object that are <code>ScopeCloseable</code> when they are removed from the registry.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
To have your scope compatible with <code>ScopeCloseable</code> values, make sure to <code>clean</code> the registry when the scope expires.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>There are two standard implementations of <code>ScopeRegistry</code>:</p>
</div>
<div class="sect4">
<h5 id="_standardscoperegistry"><a class="anchor" href="#_standardscoperegistry"></a>StandardScopeRegistry</h5>
<div class="paragraph">
<p>This is the "classic" expected <code>ScopeRegistry</code> behaviour.</p>
</div>
</div>
<div class="sect4">
<h5 id="_singleitemscoperegistry"><a class="anchor" href="#_singleitemscoperegistry"></a>SingleItemScopeRegistry</h5>
<div class="paragraph">
<p>This is a particular <code>ScopeRegistry</code> implementation : it will only hold one item and replace the held item if the binding asks for an instance of another binding.</p>
</div>
<div class="paragraph">
<p>This means that a Multiton scoped with a Scope that uses a <code>SingleItemScopeRegistry</code> will actually hold only one instance: the one corresponding to the last argument.</p>
</div>
<div class="admonitionblock caution">
<table>
<tr>
<td class="icon">
<i class="fa icon-caution" title="Caution"></i>
</td>
<td class="content">
You should NOT use this registry unless you know exactly WHAT you are doing, and WHY you are doing it.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_sub_scopes"><a class="anchor" href="#_sub_scopes"></a>Sub-scopes</h4>
<div class="paragraph">
<p>You can define a scope to be defined inside another scope.
This means that when the parent scope clears, so does all of its subscopes.</p>
</div>
<div class="listingblock">
<div class="title">Example: a simple session scope</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">val requestScope = object : SubScope&lt;Request, Session&gt;(sessionScope) {
    override fun getParentContext(context: Request) = context.session
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>In this simple example, when the session expires, then all of its associates request scoped values also expire.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_multi_binding"><a class="anchor" href="#_multi_binding"></a>Multi-binding</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Kodein allows multi bindings via a binding set.</p>
</div>
<div class="sect2">
<h3 id="set-bindings"><a class="anchor" href="#set-bindings"></a>In a Set</h3>
<div class="sect3">
<h4 id="_binding_in_a_set"><a class="anchor" href="#_binding_in_a_set"></a>Binding in a Set</h4>
<div class="paragraph">
<p>To have multiple bindings in a set, you need to:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Declare that you are using a set binding for a particular bound type.</p>
</li>
<li>
<p>Add bindings to the set.</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="title">Example creating a set of <code>Configuration</code> bindings.</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">val kodein = Kodein {
    bind() from setBinding&lt;Configuration&gt;() <i class="conum" data-value="1"></i><b>(1)</b>

    bind&lt;Configuration&gt;().inSet() with provider { FooConfiguration() } <i class="conum" data-value="2"></i><b>(2)</b>
    bind&lt;Configuration&gt;().inSet() with singleton { BarConfiguration() } <i class="conum" data-value="2"></i><b>(2)</b>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Creating a set binding of <code>Configuration</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Binding multiple <code>Configuration</code> implementations.</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>You can:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Use different binding types (such as <code>provider</code> or <code>singleton</code>) in the same set.</p>
</li>
<li>
<p>Add bindings to the same set in different modules, provided that the set has been declared first.</p>
</li>
</ul>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>You can also bind multiple bindings with arguments (such as <code>factory</code> or <code>multiton</code>) in a set <strong>as long as all bindings share the same argument type</strong>.</p>
</div>
<div class="listingblock">
<div class="title">Example creating a set of <code>Result</code> bindings.</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">val kodein = Kodein {
    bind() from argSetBinding&lt;Query, Result&gt;()

    bind&lt;Result&gt;().inSet() with factory { q: Query -&gt; Foo.query(q) }
    bind&lt;Result&gt;().inSet() with multiton { q: Query -&gt; Bar.query(q) }
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_retrieving_from_a_set"><a class="anchor" href="#_retrieving_from_a_set"></a>Retrieving from a Set</h4>
<div class="paragraph">
<p>Note that the type being bound is <code>Set&lt;T&gt;</code>, not <code>T</code>.<br>
Therefore, you need to retrieve a <code>Set</code>:</p>
</div>
<div class="listingblock">
<div class="title">Example retrieving set of <code>Configuration</code> with the generic version.</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">val configurations: Set&lt;Configuration&gt; by kodein.instance()</code></pre>
</div>
</div>
<div class="paragraph">
<p>if you are using the <code>erased</code> version, you need to retrieve thusly:</p>
</div>
<div class="listingblock">
<div class="title">Example retrieving set of <code>Configuration</code> with the erased version.</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">val configurations: Set&lt;Configuration&gt; by kodein.Instance(erasedSet())</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_in_a_map"><a class="anchor" href="#_in_a_map"></a>In a map</h3>
<div class="paragraph">
<p>Kodein does not directly support map multi-binding.
However, it is very easy to create a binding map by using a binding set.</p>
</div>
<div class="paragraph">
<p>First, create the following primitive:</p>
</div>
<div class="listingblock">
<div class="title">Example of the type alias for a map multi-binding as <code>Map&lt;String, Configuration&gt;</code>.</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">typealias ConfigurationEntry = Pair&lt;String, Configuration&gt;
typealias ConfigurationEntries = Set&lt;ConfigurationEntry&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Then, bind with keys:</p>
</div>
<div class="listingblock">
<div class="title">Example binding as in a map multibinding.</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">val kodein = Kodein {
    bind() from setBinding&lt;ConfigurationEntry&gt;()

    bind&lt;ConfigurationEntry&gt;().inSet() with factory { "foo" to FooConfiguration() }
    bind&lt;ConfigurationEntry&gt;().inSet() with multiton { "bar" to BarConfiguration() }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Finally, retrieve the map:</p>
</div>
<div class="listingblock">
<div class="title">Example retrieving a map multibinding.</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">val configurations by kodein.instance&lt;ConfigurationEntries&gt;().toMap()</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="debugging"><a class="anchor" href="#debugging"></a>Debugging</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_print_bindings"><a class="anchor" href="#_print_bindings"></a>Print bindings</h3>
<div class="paragraph">
<p>You can easily print bindings with <code>println(kodein.container.tree.bindings.description)</code>.</p>
</div>
<div class="paragraph">
<p>Here&#8217;s an example of what this prints:</p>
</div>
<div class="listingblock">
<div class="title">An example of kodein.container.tree.bindings.description:</div>
<div class="content">
<pre>        bind&lt;Dice&gt;() with factory { Int -&gt; RandomDice }
        bind&lt;DataSource&gt;() with singleton { SQLiteDataSource }
        bind&lt;Random&gt;() with provider { SecureRandom }
        bind&lt;String&gt;(tag = "answer") with instance ( Int )</pre>
</div>
</div>
<div class="paragraph">
<p>As you can see, it&#8217;s really easy to understand which type with which tag is bound to which implementation inside which scope.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Description prints type names in a "kotlin-esque" way.
      Because Kodein does not depend on <code>kotlin-reflect</code>, it uses java <code>Type</code> objects that do not contain nullability information.
      As such, the type display does not include nullability. Still, it&#8217;s easier to read <code>List&lt;*&gt;</code> than <code>List&lt;? extends Object&gt;</code>.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_recursive_dependency_loop"><a class="anchor" href="#_recursive_dependency_loop"></a>Recursive dependency loop</h3>
<div class="paragraph">
<p>When it detects a recursive dependency, Kodein will throw a <code>Kodein.DependencyLoopException</code>.
The message of the exception explains how the loop happened.</p>
</div>
<div class="listingblock">
<div class="title">An example of recursive dependency loop:</div>
<div class="content">
<pre>Kodein$DependencyLoopException: Dependency recursion:
     bind&lt;Database&gt;()
    &gt;bind&lt;User&gt;() <i class="conum" data-value="1"></i><b>(1)</b>
      &gt;bind&lt;Repository&gt;(tag = "users") <i class="conum" data-value="2"></i><b>(2)</b>
        &gt;bind&lt;Database&gt;() <i class="conum" data-value="3"></i><b>(3)</b>
    </pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td><code>Database</code> depends on <code>User</code></td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td><code>User</code> depends on <code>Repository</code> with the tag "users"</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td><code>Repository</code> with the tag "users" depends on <code>Database</code>, <strong>we have found the dependency loop!</strong>.</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_onready_callbacks"><a class="anchor" href="#_onready_callbacks"></a>OnReady callbacks</h2>
<div class="sectionbody">
<div class="paragraph">
<p>You can define callbacks to be called once the kodein instance is ready and all bindings are defined.
This can be useful to do some "starting" jobs.</p>
</div>
<div class="listingblock">
<div class="title">Example: registering a callback at binding time</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">val appModule = Kodein.Module(name = "app") {
    import(engineModule)
    onReady {
        val engine = instance&lt;Engine&gt;()
        instance&lt;Logger&gt;().info("Starting engine version ${engine.version}")
        engine.start()
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_external_source"><a class="anchor" href="#_external_source"></a>External Source</h2>
<div class="sectionbody">
<div class="paragraph">
<p>An external source is responsible for providing an answer when Kodein cannot find one.</p>
</div>
<div class="paragraph">
<p>When Kodein cannot find a binding for the required type/argument/context, then it calls the external source.</p>
</div>
<div class="listingblock">
<div class="title">Example: an external source</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">val kodein = Kodein {
    externalSource = ExternalSource { key -&gt;
        when (key.type.jvmType) { <i class="conum" data-value="1"></i><b>(1)</b>
            Whatever::class.java -&gt; when (key.argType.jvmType) { <i class="conum" data-value="2"></i><b>(2)</b>
                Unit::class.java -&gt; when (key.tag) { <i class="conum" data-value="3"></i><b>(3)</b>
                    "user" -&gt; externalFactory { existingInstance } <i class="conum" data-value="4"></i><b>(4)</b>
                    null -&gt; externalFactory { Whatever("default-value") } <i class="conum" data-value="4"></i><b>(4)</b>
                    else -&gt; null <i class="conum" data-value="6"></i><b>(6)</b>
                }
                String::class.java -&gt; when (key.tag) { <i class="conum" data-value="3"></i><b>(3)</b>
                    null -&gt; externalFactory { Whatever(it as String) } <i class="conum" data-value="5"></i><b>(5)</b>
                    else -&gt; null <i class="conum" data-value="6"></i><b>(6)</b>
                }
                else -&gt; null <i class="conum" data-value="6"></i><b>(6)</b>
            }
            else -&gt; null <i class="conum" data-value="6"></i><b>(6)</b>
        }
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The type that is required</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>The argument type (Unit if no argument)</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>The tag (null if no tag)</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>You can return an existing instance or a new one</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>The argument has been checked to be a String, so it can be safely casted</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>Return null if the external source has no answer</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The <code>externalSource</code> property takes an <code>ExternalSource</code> instance, which is a SAM interface that can be implemented by a lambda with the <code>ExternalSource { }</code> constructor.
This <code>ExternalSource</code> is called every time a new <code>Key</code> is asked but not found.
The <code>Key</code> itself contains information about the binding that was asked but not found.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
The <code>ExternalSource</code> will be called only once per unknown key.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The <code>ExternalSource</code> must return a function (which you can easily create with the <code>externalFactory</code> utility function) that takes an <code>Any?</code> argument and returns the instance.
This function will be called <strong>every time</strong> an instance is requested.
Note that if no argument is provided, the argument to the lambda will be <code>Unit</code>.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="erased-version"><a class="anchor" href="#erased-version"></a>Erased version pitfalls</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_the_type_erasure_problem"><a class="anchor" href="#_the_type_erasure_problem"></a>The type erasure problem</h3>
<div class="paragraph">
<p>When using the <code>generic</code> version on the JVM, Kodein is immune to type erasure, meaning that <code>bind&lt;List&lt;String&gt;&gt;()</code> and <code>bind&lt;List&lt;Int&gt;&gt;()</code> will represent two different bindings.<br>
Similarly, <code>kodein.instance&lt;List&lt;String&gt;&gt;()</code> and <code>kodein.instance&lt;List&lt;Int&gt;&gt;()</code> will yield two different list.</p>
</div>
<div class="paragraph">
<p>To be erasure immune, the <code>generic</code> JVM version relies heavily on the <code>generic</code> function, which is known to be slow.</p>
</div>
<div class="paragraph">
<p>To improve performance, you can use the <code>erased</code> JVM Kodein version, which is faster, but do suffer from type erasure!</p>
</div>
<div class="paragraph">
<p>Furthermore, on Javascript and Native platforms, there&#8217;s no choice: <code>erased</code> is the only version available!</p>
</div>
</div>
<div class="sect2">
<h3 id="_using_generic_and_erased_function_forms"><a class="anchor" href="#_using_generic_and_erased_function_forms"></a>Using generic and erased function forms</h3>
<div class="paragraph">
<p>Each kodein function that handles a type exists in two form: as inline (lowercased first letter) and as regular function (uppercased first letter).<br>
For example, the <code>kodein.instance</code> function also exists as <code>kodein.Instance</code>.</p>
</div>
<div class="paragraph">
<p>The uppercase functions need <code>TypeToken</code> parameters that define the type being bound / retrieved and maybe the factory&#8217;s argument.<br>
You can easily use these functions with the <code>generic</code> or <code>erased</code> functions:</p>
</div>
<div class="listingblock">
<div class="title">Example: using the <code>erased</code> function</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">val ds: DataSource by kodein.Instance(erased())</code></pre>
</div>
</div>
<div class="paragraph">
<p>By default, all inline functions are aliases to their uppercase counterparts using the <code>generic</code> function.<br>
For example, the <code>kodein.instance()</code> function is an alias to <code>kodein.Instance(generic())</code></p>
</div>
<div class="paragraph">
<p>So, when you know that you inject a type that is <strong>not generic</strong>, you can use <code>kodein.Instance(erased())</code>.</p>
</div>
</div>
<div class="sect2">
<h3 id="_erased_parameterized_generic_types"><a class="anchor" href="#_erased_parameterized_generic_types"></a>Erased parameterized generic types</h3>
<div class="paragraph">
<p>When using the <code>erased</code> function or using erased by default (either by choice on the JVM or by necessity elsewhere), you cannot represent a generic type.<br>
For example, <code>erased&lt;Set&lt;String&gt;&gt;</code> will yield a <code>TypeToken</code> representing <code>Set&lt;*&gt;</code>.</p>
</div>
<div class="paragraph">
<p>Kodein provides a way to represent a generic type in an erased way:</p>
</div>
<div class="listingblock">
<div class="title">Example: generic type tokens, using erased</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">erasedComp1&lt;Set&lt;String&gt;, String&gt;()                         // Represents a Set&lt;String&gt;
erasedComp2&lt;Map&lt;Int, String&gt;, Int, String&gt;()               // Represents a Map&lt;Int, String&gt;
erasedComp3&lt;Triple&lt;Int, String, Int&gt;, Int, String, Int&gt;()  // Represents a Triple&lt;Int, String, Int&gt;</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The type parameter themselves are erased, meaning that you cannot represent a multi-level generic type.
      You can, however, construct your own <code>CompositeTypeToken</code> to represent such a type.
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_bind_the_same_type_to_different_factories"><a class="anchor" href="#_bind_the_same_type_to_different_factories"></a>Bind the same type to different factories</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Yeah, when I said earlier that "you can have multiple bindings of the same type, as long as they are bound with different tags", I lied.
Because each binding is actually a <em>factory</em>, the binding tuples are not <code>([BindType], [Tag])</code> but actually <code>([ContextType], [BindType], [ArgType], [Tag])</code> (note that providers and singletons are bound as <code>([BindType], Unit, [Tag])</code>).
This means that any combination of these three information can be bound to it&#8217;s own factory, which in turns means that you can bind the same type without tagging to different factories.</p>
</div>
<div class="admonitionblock caution">
<table>
<tr>
<td class="icon">
<i class="fa icon-caution" title="Caution"></i>
</td>
<td class="content">
Please be cautious when using this knowledge, as other less thorough readers may get confused with it.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_hack_the_container"><a class="anchor" href="#_hack_the_container"></a>Hack the container!</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The KodeinContainer is the sacred Kodein object that contains all bindings and is responsible for retrieval.
You can access it with <code>kodein.container</code>.
In it, each <code>Binding</code> is bound to a <code>Kodein.Key</code>.</p>
</div>
<div class="paragraph">
<p>In fact, all Kodein functions are proxies to this container API.</p>
</div>
<div class="paragraph">
<p>When defining bindings, in the <code>Kodein.Builder</code>, you can access the <code>container</code> property to bind factories to a <code>Kodein.Key</code> or a <code>Kodein.Bind</code>.</p>
</div>
<div class="sect2">
<h3 id="_tag_vs_context_vs_argument"><a class="anchor" href="#_tag_vs_context_vs_argument"></a>Tag vs context vs argument</h3>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">&nbsp;</th>
<th class="tableblock halign-left valign-top">Binding identification</th>
<th class="tableblock halign-left valign-top">accessible by the binding <em>itself</em>*</th>
<th class="tableblock halign-left valign-top">accessible by the binding function</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>tag</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">instance</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">no</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">no</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>context</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">type</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">yes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">yes</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>argument</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">type</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">no</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">yes</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect2">
<h3 id="_explore_bindings"><a class="anchor" href="#_explore_bindings"></a>Explore bindings</h3>
<div class="paragraph">
<p>You can access a <strong>copy</strong> of the bindings map with <code>kodein.container.bindings</code>.<br>
From this <code>Map&lt;Kodein.Key, Factory&lt;*, *&gt;&gt;</code>, you can explore all bindings, their keys and factories.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_community"><a class="anchor" href="#_community"></a>Community</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_contribute"><a class="anchor" href="#_contribute"></a>Contribute</h3>
<div class="paragraph">
<p>Contributions are very welcome and greatly appreciated! The great majority of pull requests are eventually merged.</p>
</div>
<div class="paragraph">
<p>To contribute, simply fork <a href="https://github.com/Kodein-Framework/Kodein-DI">the project on Github</a>, fix whatever is iching you, and submit a pull request!</p>
</div>
<div class="paragraph">
<p>I am sure that this documentation contains typos, inaccuracies and languages error (English is not my mother tongue).
If you feel like enhancing this document, you can propose a pull request that modifies <a href="https://github.com/Kodein-Framework/Kodein-DI/tree/master/doc">the documentation documents</a>.
(Documentation is auto-generated from those).</p>
</div>
</div>
<div class="sect2">
<h3 id="_lets_talk"><a class="anchor" href="#_lets_talk"></a>Let&#8217;s talk!</h3>
<div class="paragraph">
<p>You&#8217;ve read so far?! <strong>You&#8217;re awesome!</strong><br>
Why don&#8217;t you drop by the <a href="https://kotlinlang.slack.com/messages/kodein/">Kodein Slack channel</a> on Kotlin&#8217;s Slack group?</p>
</div>
</div>
</div>
</div>
</article>
<aside class="toc sidebar" data-title="Contents" data-levels="2">
  <div class="toc-menu"></div>
</aside>
  </div>
</main>
</div>
<footer class="footer">
<!--  <a class="navbar-item" href="https://kodein.net" target="_blank">-->
<!--    <div style="padding: 0.5rem;opacity:0.8;">by</div>-->
<!--    <div style="font-weight: 700;">KODEIN</div>-->
<!--    <div style="font-weight: 300;opacity:0.8;">Koders</div>-->
<!--  </a>-->
</footer>
<script src="../../_/js/site.js"></script>
<script async src="../../_/js/vendor/highlight.js"></script>
  </body>
</html>
